# 单页面登录
## 1. 简介
### 1.1 JSP登录对比
单页面登录和以往JSP模式的登录的登录有很大不同。JSP页面往往使用重定向来处理未登录问题、权限控制也可以完全写在JSP中；而在单页面应用中，前后端是完全分离的，前端页面跳转无法由后台控制、需要根据后台返回的信息来自行控制登录逻辑。
### 1.2 解决关键点
#### 1. 权限页面的未登录拦截控制
系统页面中通常都会有需要登录后才能浏览和操作的页面（简称为权限页面），未登录状态进入权限页面是不允许的，这时候需要在前端做页面访问的拦截控制。
#### 2. 前后端通讯规范约定
单页面应用前后端完全分离，通讯往往采用Ajax异步通讯（为了维持系统的单页面特性，表单提交往往是不合适的），因为用户未登录时不应该使用重定向，而应该约定一种协议来标识未登录状态。
#### 3. 登录信息数据的全局存取
登录数据是公共数据，往往很多页面会使用到，因而登录信息需要全局保存，存储位置的选择是一个关键点。
#### 4. 会话状态的存储
会话状态一般使用Session，在JSP项目中，默认前端会使用一个key为JSESSIONID的Cookie来存取Session，此种方式存在CSRF（跨站点请求伪造）隐患。
#### 5. 自动登录处理
WEB登录为了简化用户的登录步骤，通常会提供自动登录功能，自动登录功能的关键点在于前后端信息的存储、信息加解密。
#### 6. 前端操作缓存
在前端，登录作为拦截器，对于未登录的权限操作必然会做一个拦截，然后在登录以后再进行这个操作；为优化体验，可以在登录后自动执行登录前的操作，这需要前端来实现操作缓存。
## 2. 方案
### 2.1 权限页面的未登录拦截控制
未登录的访问拦截，在JSP程序中，往往使用拦截器（或称过滤器）来控制，在前端中，也可以用这样的思路来解决这个问题，在页面访问之前加一层拦截，由拦截来控制是否要跳转到目标页面。
在单页面应用中，路由器是一个必备的组件，用来控制页面的跳转，因而拦截器放在路由层是最合适的选择。
路由层的设计有很多种实现，下面示范两种在Angular的ui-router中实现的方式。
#### 2.1.1 方式一
先了解ui-router中的两个概念：resolve对象、抽象状态。
resolve对象：resolve对象是一个value为function的键值对集合，ui-router在加载页面前会将所有的resolve函数执行一遍，并且只有在所有的function都正确执行并返回后，才进行下一步路由的跳转。可以利用resolve的这个特性来实现路由的拦截。
抽象状态：抽象状态不同于普通状态，它不能够实现页面跳转，只能由子状态去实现，从而我们可以将拦截器写在一个抽象状态内部，然后所有需要经过过滤的状态都定义为该抽象状态的子状态，从而实现拦截跳转。
实现代码如下：
```
//登录检测
{
  state : "loginCheck",
  url:"",
  abstract: true,    //抽象状态，不能被激活
  resolve : {
    login : function($host, $q, $state){
      var defer = $q.defer();
      $host.checkLogin(function(success){
        if(!success){
          $state.go("login");
          // window.location.href = "#/login";
        }
      })
      return defer.promise();
    }
  }
},
//需要登录过滤的地址
{
  state : "loginCheck.api",
  url : "/api",
  views: {
    '': {
      template: '<div class="page-container" style="height: 100%"></div>'
    },
    'sidebar@index': {templateUrl: 'modules/common/html/sidebar.html'},      'top@index': {templateUrl: 'modules/common/html/top.html'}
  },
  useModule: 'com',
  params: {"data": null},
  resolve : {
    run : function(){
      $(".page-sidebar").css({minHeight:$(window).height()});
    }
  }
},
```
#### 2.1.2 方式二
路由器跳转的过程会触发多个回调事件，可以利用这些事件实现拦截功能。下面使用路由器的回调事件'$stateChangeStart'来实现登录检测和拦截，event.preventDefault();是关键操作。
``` undefined
//判断是否登录
$rootScope.$on('$stateChangeStart',function(event, toState, toParams, fromState, fromParams){

  //切换路由状态,可以在这里对session做校验
  $http.get('/ycm-usercenter/login/validateLogin.action',{}).success(function(data,status,headers,config){  
    // 如果用户不存在
    if(data.error==1){
      event.preventDefault();// 取消默认跳转行为
      $state.go("login");//跳转到登录界面
    }
    }).error(function(data,status,headers,config){
        $state.go("login");
    });  
  

  })
```


### 2.2 前后端通讯规范约定
后端对于权限资源未登录时的请求，应该予以拒绝访问，并返回恰当的信息以提示前端。此处提示方式通常有两种：HTTP响应码、返回信息。
HTTP响应码：HTTP协议中约定有未授权访问的响应码，为401。后端以此作为登录标识。
返回信息：通过自定义的返回格式信息来返回，比如JSON数据：{error : 10}，前端收到返回信息后，通过判断error=10来进行未登录操作。
推荐使用返回信息的方式来处理。原因：
1. 此处未登录属于业务层的标识，不为协议层的标识，HTTP返回码为协议层的标识。
2. 业务层通常会定义错误信息的返回格式，这样处理符合业务层的已定义规范。
### 2.3 登录信息数据的全局存取
登录的用户信息和其他信息，通常在很多页面会使用到（一个典型的业务场景：商品详细信息页面都过对比商品的创建者ID和登录用户ID来决定是否显示商品编辑按钮），此处应该保存为全局变量。全局变量的保存方式有很多，比如直接保存于window对象；在Angualr中，可以采用$rootScope进行存储、这样Angualr还能帮助程序自动更新UI状态。
### 2.4 会话状态的存储
#### 2.4.1 前端存储
会话状态通常的保存为Session，由于Session存在CSRF攻击问题（根源在于Cookie会自动加在每次HTTP请求的请求头中），此处可以采用HTML5的存储新特性sessionStorage和localStorage进行存储，这两种方式都是以同源为作用域，即不同域名之间的数据不能共享。
sessionStorage:针对一个 session 的数据存储。
localStorage:没有时间限制的数据存储。

sessionStorage和localStorage提供了相同的语法来进行数据的操作：
``` undefined
// 保存数据
sessionStorage.setItem(Key, value);

// 读取数据
sessionStorage.getItem(Key);

// 删除数据
sessionStorage.removeItem("key");

// 清空所有数据
sessionStorage.clear();
```
sessionStorage和localStorage可以兼容到IE8，现代浏览器都支持，若要实现IE7、IE6的兼容，可以使用其自带的UserData对象自行封装。
#### 2.4.2 后端存储
由于前端不使用Cookie来存储状态，则后端的Session也不可用，需要另行实现登录状态的存取和时间控制。这里可以采用数据层存储的方式，此种方式应当注意2个问题：
1. 数据存储在持久层或缓存层都可以。
2. 会话的失效时间需要自行控制，因而需要登录的时间存储。
### 2.5 自动登录处理
自动登录需要在前端保存敏感信息，比如用户名、密码，而在浏览器端保存这些敏感信息若不加处理是比较危险的，因而信息的存储位置和加解密是自动登录处理的关键点。关于信息存储，由于Cookie的安全性缺陷，这里建议使用localStorage进行信息存储。关于信息加解密，需要注意下面几点
1. 由于数据要在所有自动登录的用户浏览器端保存，所以对于密钥，不同的用户一定不能使用同一个密钥，否则密钥一旦被破解则会对所有的用户构成威胁。
2. 对于密码加密，可以使用用户名加盐（随机字符串）生成密钥的方式来加密（加密方式可以使用不可逆的MD5），这样需要服务器端保存每个用户对应的随机串，且每次自动登录后都重置该随机串。
### 2.6 前端操作缓存
登录操作会阻止用户想要进行的操作，比如提交一个表单、跳转一个页面。为优化体验，这些操作可以在登录成功后自动为用户执行，这就涉及前端操作缓存。缓存的原理是：保存用户的整个操作中所有的数据信息，数据包含请求的全部信息、回调信息。
#### 2.6.1 缓存层提取
缓存组件应当剥离为一个单独的组件，然后对外提供接口或事件来供其他地方调用。
该组件使用一个数组对象保存所有请求，以便将来可以重新发起这些请求。
该组件还提供一个重新发起请求的方法，当登录成功后被调用。

```
angular.module('http-auth-interceptor-buffer', [])
        .factory('httpBuffer', ['$injector', function ($injector) {
    // 保存所有请求，以便将来可以重新发起这些请求
    var buffer = [];

    var $http;
    // 重新发起请求
    function retryHttpRequest(config, deferred) {
        function successCallback(response) {
            deferred.resolve(response);
        }

        function errorCallback(response) {
            deferred.reject(response);
        }

        $http = $http || $injector.get('$http');
        $http(config).then(successCallback, errorCallback);
    }

    return {
        /**
         * 添加HTTP请求到缓存对象
         * @param config　HTTP请求参数
         * @param deferred　延迟响应
         * @returns 缓存的请求数量
         */
        append: function (config, deferred) {
            buffer.push({
                config: config,
                deferred: deferred
            });
            return buffer.length;
        },

        /**
         * 丢弃或拒绝（如果给出原因）所有缓存的请求.
         */
        rejectAll: function (reason) {
            if (reason) {
                for (var i = 0; i < buffer.length; i++) {
                    buffer[i].deferred.reject(reason);
                }
            }
            buffer = [];
        },

        /**
         * 重新发送所有请求，并清空缓存
         */
        retryAll: function (updater) {
            for (var i = 0; i < buffer.length; i++) {
                retryHttpRequest(updater(buffer[i].config), buffer[i].deferred);
            }
            buffer = [];
        }
    };
}]);
```

#### 2.6.2 操作还原
缓存组件需要与http请求拦截器协同使用。当服务器返回“未登录”标识后，缓存所有的请求。当重新登录成功后或者登录失败或者取消登录时，清空缓存的请求。
重新登录成功后，可重新发起请求。
```
httpBuffer.retryAll(updater)
```

## 3 其他
### 3.1 Ajax请求组件的封装
Ajax请求组件通常在各个框架中都有封装，比如jQuery、Angular、Zepto，为了更好的和自己的业务结合（比如添加请求头、处理公共返回结果），可以再进行一层封装，下面是使用jQuery Ajax进行再封装的实例：
```
/*
 * 异步发送请求
 * 
 * @url 			: <string>		//请求的地址，可以带get参数
 * 
 * @postData		: <json>		//发送的数据，post类型
 * 
 * @callback(data, success) : <function>		//返回函数，带一个参数，即服务器的输出字符，必须为json格式
 * 		@data		: <json>		//数据
 * 		@success	: <boolean>		//是否请求成功
 * 
 *
 * @options 		: <json>		//jQuery原生请求参数
 * 
 * @properties 		: <json>		//方法属性
 * 	{
 * 		quiet : true/false,		//是否展示错误信息
 * 	}
 *
 */
class Ajax{
  constructor($http, $q){
    this.$http = $http;
    this.$q = $q;
  }
  /**
   * POST方法
   */
  post = (url, postData, callback, options, properties)=>{
    this._request(url, postData, callback, $.extend({type:"POST"}, options), properties);
  }
  /**
   * GET方法
   */
  get = (url, postData, callback, options, properties)=>{
    this._request(url, postData, callback, $.extend({type:"GET"}, options), properties);
  }
  
  _request = (url, postData, callback, options, properties)=>{
    var defer = this.$q.defer();
    var promise = defer.promise;
    promise.then(
      function(returnInfo){
        if(!returnInfo.success){
          $$.toast(returnInfo.data.message || "操作失败~", {delay : 1500});
        }
        callback(returnInfo.data, returnInfo.success);
      }
    );
    properties = $.extend({}, properties);
    $.ajax($.extend(
      {
        url: url? url : (window.location.href+""),
        success: function(data){
          
          if(data=="OK" || data=="ok"){
            data = {error : 0};
          }
          if(data == "fail" || data=="Fail"){
            data = {erro : 1, message : "操作失败"};
          }
          defer.resolve({data : data, success : true});
        },
        data : postData,
        error : function(request, error, message){
          defer.resolve({data : {error : 1, message : "请求失败"}, success : false})
        }
        
      },
      options,
      {
        dataType : options.dataType? options.dataType : "json"
      }
      )
    );
    return defer.promise;
  }
}
Ajax.$inject = ["$http", "$q"];

```  
### 3.2 登录操作的交互方式
登录操作的交互方式可以灵活实现，常用的方式有弹窗和跳转新路由。为让用户体验达到最佳，建议使用弹窗的登录方式。

## 4. 登录架构图
以上总结为每个技术点的解决方案，下图是单页面登录流程图，并对以上技术进行了汇总。
汇总架构图包含了单页面登录处理的各个环节
  * 路由配置
  * 登录业务层
    * 地址拦截
	* 登录用户内存检测
	* 登录token检测(包含登录信息)
	* 登录成功处理
	* 登录失败切换登录组件
  * 封装Ajax组件
  * 服务器处理
    * 拦截器拦截请求
	* 登录检测处理
	* 数据返回
	
![](/assets/单页面登录.png)